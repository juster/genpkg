#!/usr/bin/env perl

use warnings 'FATAL' => 'all';
use strict;

use Text::Wrap qw(wrap);

my %ACTIONS_OF = ('MM',
                  { 'build'   => [ q{/usr/bin/perl Makefile.PL}, q{make} ],
                    'check'   => [ q{make test} ],
                    'package' => [ q{make DESTDIR="$pkgdir" install} ]
                   },
                  'MB',
                  { 'build'   => [ q{/usr/bin/perl Build.PL}, q{./Build} ],
                    'check'   => [ q{./Build test} ],
                    'package' => [ q{./Build install} ]
                   } );

my $PBBEG = <<'END_BEG';
# Maintainer : %s
# Generator  : pbjam %s
END_BEG

my %FUNCFMTS;
$FUNCFMTS{'build'} = <<'END_FMT';
build() {
  ( export PERL_MM_USE_DEFAULT=1 PERL5LIB=""                 \
      PERL_AUTOINSTALL=--skipdeps                            \
      PERL_MM_OPT="INSTALLDIRS=vendor DESTDIR='$pkgdir'"     \
      PERL_MB_OPT="--installdirs vendor --destdir '$pkgdir'" \
      MODULEBUILDRC=/dev/null

    cd "$_distdir"
%s
  )
}
END_FMT

$FUNCFMTS{'check'} = <<'END_FMT';
check() {
  ( export PERL_MM_USE_DEFAULT=1 PERL5LIB=""
    cd "$_distdir"
%s
  )
}
END_FMT

$FUNCFMTS{'package'} = <<'END_FMT';
package() {
    cd "$_distdir"
%s
    find "$pkgdir" -name .packlist -o -name perllocal.pod -delete
}
END_FMT

my $PBEND = <<'END_END';
# Local Variables:
# mode: shell-script
# sh-basic-offset: 2
# End:
# vim:set ts=2 sw=2 et:
END_END

# Convert actions array into lines of bash to insert into template.
sub bashify
{
    my (@lines) = @_;
    my $txt = join qq{\n}, map { s/^/    /gm; $_ } @lines;
    return $txt
}

sub mungevars
{
    my ($vars) = @_;
    $vars->{'options'} = [ '!emptydirs' ];

    # Replace version string in 'source' entry & 'distdir' with
    # $pkgver parameter.
    for my $v (qw/pkgver distdir/) {
        die "$0: $v is undefined" unless defined $vars->{$v}[0];
    }
    my $ver = $vars->{'pkgver'}[0];
    s/\Q$ver\E/\${pkgver}/g for ($vars->{'source'}[0], $vars->{'distdir'}[0]);

    return;
}

sub printpb
{
    my ($btype, $pbvars) = @_;
    my $acts = $ACTIONS_OF{$btype}
        or die "$0: unknown build type ($btype)\n";

    my $pkger = $pbvars->{'packager'}[0] || 'Anonymous';
    printf $PBBEG, $pkger, $pbvars->{'pbjver'}[0];
    print "\n";

    # 'pbfields' will recognize and PKGBUILD fields in the data
    # and print them out in order, wordwrapping arrays.
    open my $pbfields, '|pbfields' or die "failed to pipe to pbfields: $!";
    while (my ($name, $vals) = each %$pbvars) {
        print $pbfields $name, "\n";
        print $pbfields $_, "\n" for @$vals;
        print $pbfields "\n";
    }
    close $pbfields;

    my $distdir = $pbvars->{'distdir'}[0];
    print qq{_distdir="\${srcdir}/$distdir"\n};
    print "\n";

    for my $func (qw/build check package/) {
        my $funclines = $acts->{$func};
        printf $FUNCFMTS{$func}, bashify(@$funclines);
        print "\n";
    }
    print $PBEND;
}

sub readvars
{
    local $/ = ""; # split records on empty lines
    my (%pbvars);
    while (<STDIN>) {
        my ($name, @vals) = split /\n/;
        $pbvars{$name} = [ @vals ];
    }
    return \%pbvars;
}

sub main
{
    my ($type) = @_;
    my $vars = readvars();
    mungevars($vars);
    printpb($type, $vars);
}

my $type = shift or die qq{$0: please provide "MM" or "MB" as argument\n};
main($type);
